<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endless Shooter Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #1a202c;
            color: #e2e8f0;
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            flex-direction: column;
            padding: 1rem;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #2d3748;
            padding: 1rem;
            border-radius: 1rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            width: 100%;
            max-width: 500px;
        }

        canvas {
            background-color: #4a5568;
            border-radius: 0.5rem;
            border: 2px solid #a0aec0;
            touch-action: none;
            width: 100%;
            height: auto;
        }

        #info-panel {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-top: 1rem;
            padding: 0 0.5rem;
        }
        
        #score-display {
            color: #48bb78;
        }
        
        #lives-display {
            color: #ef4444;
        }

        .game-button {
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background-image: linear-gradient(to right, #4c51bf, #6b46c1);
            border: none;
            border-radius: 9999px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .game-button:hover {
            transform: translateY(-2px);
            background-image: linear-gradient(to right, #6b46c1, #4c51bf);
        }
        
        #controls-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            margin-top: 1rem;
        }

        /* Styling for the new circular control pad */
        #direction-controls-circle {
            position: relative;
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background-color: #4a5568;
            border: 2px solid #a0aec0;
            margin-bottom: 1rem;
        }

        .game-arrow-button {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: #2d3748;
            color: white;
            font-size: 1.5rem;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease-in-out;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .game-arrow-button:active {
            background-color: #1a202c;
        }

        #upButton {
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
        }
        #downButton {
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
        }
        #leftButton {
            left: 5px;
            top: 50%;
            transform: translateY(-50%);
        }
        #rightButton {
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
        }
        /* End new button styling */

        #message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #2d3748;
            padding: 2rem 3rem;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            display: none;
            z-index: 10;
            text-align: center;
            font-size: 1.5rem;
        }

        #message-box button {
            margin-top: 1rem;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="info-panel">
            <h2 id="score-display" class="text-xl font-bold">Score: 0</h2>
            <h2 id="lives-display" class="text-xl font-bold">Lives: 3</h2>
        </div>
        <canvas id="gameCanvas"></canvas>
    </div>

    <!-- Container for all game controls -->
    <div id="controls-container">
        <button id="startButton" class="game-button">เริ่มเกม</button>
        <!-- Directional controls, hidden initially -->
        <div id="game-controls" class="hidden">
            <!-- New circular direction control pad -->
            <div id="direction-controls-circle">
                <button id="upButton" class="game-arrow-button">▲</button>
                <button id="leftButton" class="game-arrow-button">◀</button>
                <button id="downButton" class="game-arrow-button">▼</button>
                <button id="rightButton" class="game-arrow-button">▶</button>
            </div>
            <!-- Shoot button -->
            <button id="shootButton" class="game-button mt-4">ยิง!</button>
        </div>
    </div>

    <!-- The message box for "Game Over" and "Play Again" -->
    <div id="message-box">
        <h2 class="text-3xl font-bold mb-4">เกมจบแล้ว</h2>
        <p id="message-text"></p>
        <button id="message-button" class="game-button">เล่นอีกครั้ง</button>
    </div>

    <script>
        // Get canvas and context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startButton = document.getElementById('startButton');
        const gameControls = document.getElementById('game-controls');
        const upButton = document.getElementById('upButton');
        const downButton = document.getElementById('downButton');
        const leftButton = document.getElementById('leftButton');
        const rightButton = document.getElementById('rightButton');
        const shootButton = document.getElementById('shootButton');
        const scoreDisplay = document.getElementById('score-display');
        const livesDisplay = document.getElementById('lives-display');
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');
        const messageButton = document.getElementById('message-button');

        // Game state variables
        let gameActive = false;
        let animationFrameId;
        let score = 0;
        let lives = 3; // Initial number of lives
        let obstacleSpawnInterval;

        // Player properties
        const player = {
            x: 0,
            y: 0,
            width: 20,
            height: 20,
            speed: 5,
            color: '#4299e1'
        };
        let PLAYER_MAX_Y = 0;

        // Bullet properties
        let bullets = [];
        const bulletProperties = {
            width: 4,
            height: 10,
            speed: 7,
            color: '#a0aec0'
        };

        // Obstacle properties
        let obstacles = [];
        const obstacleProperties = {
            width: 20,
            height: 20,
            speed: 2,
            color: '#e53e3e'
        };

        // Player movement state
        let rightPressed = false;
        let leftPressed = false;
        let upPressed = false;
        let downPressed = false;

        // Event listeners for keyboard input (for desktop use)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Right' || e.key === 'ArrowRight') {
                rightPressed = true;
            } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
                leftPressed = true;
            } else if (e.key === 'Up' || e.key === 'ArrowUp') {
                upPressed = true;
            } else if (e.key === 'Down' || e.key === 'ArrowDown') {
                downPressed = true;
            } else if (e.key === ' ' && gameActive) {
                shoot();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'Right' || e.key === 'ArrowRight') {
                rightPressed = false;
            } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
                leftPressed = false;
            } else if (e.key === 'Up' || e.key === 'ArrowUp') {
                upPressed = false;
            } else if (e.key === 'Down' || e.key === 'ArrowDown') {
                downPressed = false;
            }
        });

        // Event listeners for buttons
        upButton.addEventListener('mousedown', () => upPressed = true);
        upButton.addEventListener('mouseup', () => upPressed = false);
        upButton.addEventListener('touchstart', (e) => { e.preventDefault(); upPressed = true; });
        upButton.addEventListener('touchend', (e) => { e.preventDefault(); upPressed = false; });
        
        downButton.addEventListener('mousedown', () => downPressed = true);
        downButton.addEventListener('mouseup', () => downPressed = false);
        downButton.addEventListener('touchstart', (e) => { e.preventDefault(); downPressed = true; });
        downButton.addEventListener('touchend', (e) => { e.preventDefault(); downPressed = false; });

        leftButton.addEventListener('mousedown', () => leftPressed = true);
        leftButton.addEventListener('mouseup', () => leftPressed = false);
        leftButton.addEventListener('touchstart', (e) => { e.preventDefault(); leftPressed = true; });
        leftButton.addEventListener('touchend', (e) => { e.preventDefault(); leftPressed = false; });

        rightButton.addEventListener('mousedown', () => rightPressed = true);
        rightButton.addEventListener('mouseup', () => rightPressed = false);
        rightButton.addEventListener('touchstart', (e) => { e.preventDefault(); rightPressed = true; });
        rightButton.addEventListener('touchend', (e) => { e.preventDefault(); rightPressed = false; });

        shootButton.addEventListener('click', shoot);

        // Touch event listeners for mobile devices on the canvas
        canvas.addEventListener('touchstart', handleTouchStart);
        canvas.addEventListener('touchmove', handleTouchMove);
        canvas.addEventListener('touchend', handleTouchEnd);

        let touchStartX = 0;
        let touchStartY = 0;

        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
        }

        function handleTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const moveDistanceX = touch.clientX - touchStartX;
            const moveDistanceY = touch.clientY - touchStartY;
            const threshold = 10;

            // Reset all movement states
            leftPressed = false;
            rightPressed = false;
            upPressed = false;
            downPressed = false;
            
            if (Math.abs(moveDistanceX) > Math.abs(moveDistanceY) && Math.abs(moveDistanceX) > threshold) {
                if (moveDistanceX > 0) {
                    rightPressed = true;
                } else {
                    leftPressed = true;
                }
            } else if (Math.abs(moveDistanceY) > Math.abs(moveDistanceX) && Math.abs(moveDistanceY) > threshold) {
                if (moveDistanceY > 0) {
                    downPressed = true;
                } else {
                    upPressed = true;
                }
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            leftPressed = false;
            rightPressed = false;
            upPressed = false;
            downPressed = false;
        }

        // Initialize the game state
        function initGame() {
            // Reset player position based on new canvas size
            player.x = canvas.width / 2 - player.width / 2;
            player.y = canvas.height - 30;
            PLAYER_MAX_Y = canvas.height * 0.75; // Player cannot move above 75% of the screen height

            // Clear existing obstacles and bullets
            obstacles = [];
            bullets = [];
            score = 0;
            lives = 3;
            scoreDisplay.textContent = `Score: ${score}`;
            livesDisplay.textContent = `Lives: ${lives}`;
        }

        // Draw the player
        function drawPlayer() {
            ctx.beginPath();
            ctx.rect(player.x, player.y, player.width, player.height);
            ctx.fillStyle = player.color;
            ctx.fill();
            ctx.closePath();
        }

        // Draw the obstacles
        function drawObstacles() {
            obstacles.forEach(obstacle => {
                ctx.beginPath();
                ctx.rect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                ctx.fillStyle = obstacle.color;
                ctx.fill();
                ctx.closePath();
            });
        }
        
        // Draw the bullets
        function drawBullets() {
            bullets.forEach(bullet => {
                ctx.beginPath();
                ctx.rect(bullet.x, bullet.y, bullet.width, bullet.height);
                ctx.fillStyle = bullet.color;
                ctx.fill();
                ctx.closePath();
            });
        }

        // Create a new bullet
        function shoot() {
            if (!gameActive) return;
            bullets.push({
                x: player.x + player.width / 2 - bulletProperties.width / 2,
                y: player.y,
                width: bulletProperties.width,
                height: bulletProperties.height,
                speed: bulletProperties.speed,
                color: bulletProperties.color
            });
        }
        
        // Check for collisions between player and obstacles
        function checkPlayerCollision() {
            for (let i = 0; i < obstacles.length; i++) {
                const obs = obstacles[i];
                if (
                    player.x < obs.x + obs.width &&
                    player.x + player.width > obs.x &&
                    player.y < obs.y + obs.height &&
                    player.y + player.height > obs.y
                ) {
                    // Collision detected
                    lives--;
                    livesDisplay.textContent = `Lives: ${lives}`;
                    if (lives > 0) {
                        // Reset player position and clear obstacles, but continue game
                        obstacles = [];
                        player.x = canvas.width / 2 - player.width / 2;
                        player.y = canvas.height - 30;
                    } else {
                        endGame();
                    }
                    return true;
                }
            }
            return false;
        }
        
        // Check for collisions between bullets and obstacles
        function checkBulletCollision() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                for (let j = obstacles.length - 1; j >= 0; j--) {
                    const obs = obstacles[j];
                    if (
                        bullet.x < obs.x + obs.width &&
                        bullet.x + bullet.width > obs.x &&
                        bullet.y < obs.y + obs.height &&
                        bullet.y + bullet.height > obs.y
                    ) {
                        // Collision detected, remove both and increase score
                        bullets.splice(i, 1);
                        obstacles.splice(j, 1);
                        score += 100; // Increase score only for hitting an obstacle
                        scoreDisplay.textContent = `Score: ${score}`;
                        return; // Exit inner loop to prevent errors with modified array
                    }
                }
            }
        }

        // Game loop
        function update() {
            if (!gameActive) return;

            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw game elements
            drawPlayer();
            drawObstacles();
            drawBullets();

            // Update player position
            if (rightPressed && player.x < canvas.width - player.width) {
                player.x += player.speed;
            }
            if (leftPressed && player.x > 0) {
                player.x -= player.speed;
            }
            if (upPressed && player.y > PLAYER_MAX_Y) {
                player.y -= player.speed;
            }
            if (downPressed && player.y < canvas.height - player.height) {
                player.y += player.speed;
            }

            // Update obstacle positions
            obstacles.forEach(obstacle => {
                obstacle.y += obstacle.speed;
            });
            
            // Update bullet positions and remove off-screen bullets
            bullets = bullets.filter(bullet => bullet.y > 0);
            bullets.forEach(bullet => {
                bullet.y -= bullet.speed;
            });

            // Check for game conditions
            checkBulletCollision();
            if (checkPlayerCollision()) {
                return;
            }
            
            // Score no longer increases over time
            // score += 1;
            // scoreDisplay.textContent = `Score: ${score}`;

            // Loop the animation
            animationFrameId = requestAnimationFrame(update);
        }

        // End the game and display message
        function endGame() {
            gameActive = false;
            clearInterval(obstacleSpawnInterval);
            cancelAnimationFrame(animationFrameId);
            messageBox.style.display = 'block';
            gameControls.classList.add('hidden');
            startButton.classList.remove('hidden');

            // Update the message text to show the final score
            messageText.textContent = `คุณทำคะแนนได้ ${score} คะแนน`;
            
            messageButton.onclick = () => {
                messageBox.style.display = 'none';
                initGame();
                startGame();
            };
        }

        // Start the game
        function startGame() {
            startButton.classList.add('hidden');
            gameControls.classList.remove('hidden');
            gameActive = true;
            // Spawn obstacles at a regular interval
            obstacleSpawnInterval = setInterval(() => {
                obstacles.push({
                    x: Math.random() * (canvas.width - 20),
                    y: -20,
                    width: obstacleProperties.width,
                    height: obstacleProperties.height,
                    speed: obstacleProperties.speed,
                    color: obstacleProperties.color
                });
            }, 1000); // Spawn a new obstacle every 1 second
            update();
        }
        
        // Function to set canvas size and reset game on window resize
        function resizeCanvas() {
            const size = Math.min(window.innerWidth * 0.9, window.innerHeight * 0.8, 500);
            canvas.width = size;
            canvas.height = size;
            initGame();
            if (!gameActive) {
                drawPlayer();
            }
        }

        // Event listener for the start button
        startButton.addEventListener('click', () => {
            initGame();
            startGame();
        });

        // Initial setup
        window.onload = function () {
            resizeCanvas();
        }

        // Listen for window resize events to keep the game responsive
        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>
