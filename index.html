<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>‡πÄ‡∏Å‡∏°‡∏´‡∏±‡∏ß‡πÉ‡∏à‡∏Å‡∏£‡∏∞‡∏û‡∏£‡∏¥‡∏ö</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body, html {
            overscroll-behavior: none;
            touch-action: manipulation;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            font-family: 'Inter', sans-serif;
        }
        canvas {
            display: block;
            margin: 0 auto;
        }
        .boss-health-bar-container {
            width: 80%;
            height: 20px;
            background-color: #555;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #333;
            margin-top: 10px;
        }
        .boss-health-bar {
            height: 100%;
            background-color: #ff4136;
            transition: width 0.2s ease-in-out;
        }
        .dialogue-box {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            max-width: 80%;
            padding: 1rem;
            background-color: rgba(255, 255, 255, 0.9);
            border: 2px solid #000;
            border-radius: 1rem;
            font-size: 1rem;
            text-align: center;
            display: none;
            z-index: 10;
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 flex flex-col items-center justify-center min-h-screen p-4">
    <div class="flex flex-col items-center space-y-4 max-w-full overflow-hidden">
        <h1 class="text-3xl md:text-5xl font-extrabold text-gray-800 dark:text-white text-center">‡πÄ‡∏Å‡∏°‡∏´‡∏±‡∏ß‡πÉ‡∏à‡∏Å‡∏£‡∏∞‡∏û‡∏£‡∏¥‡∏ö</h1>
        <div id="score-container" class="text-xl md:text-2xl font-bold text-gray-700 dark:text-gray-300">
            ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô: <span id="score-text">0</span>
        </div>
        <div id="boss-info" class="hidden flex-col items-center">
            <span class="text-lg md:text-xl font-bold text-gray-700 dark:text-gray-300">‡∏û‡∏•‡∏±‡∏á‡∏ä‡∏µ‡∏ß‡∏¥‡∏ï‡∏ö‡∏≠‡∏™</span>
            <div id="boss-health-bar-container" class="boss-health-bar-container">
                <div id="boss-health-bar" class="boss-health-bar"></div>
            </div>
        </div>
        <div id="game-container" class="relative"></div>
        <div id="end-game-text" class="absolute hidden flex flex-col items-center justify-center w-full h-full z-10 text-white bg-black bg-opacity-70 rounded-xl">
            <span id="end-game-title" class="text-3xl md:text-5xl font-bold"></span>
            <span id="final-score" class="text-xl md:text-3xl mt-4">‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢: 0</span>
            <button id="play-again-button" class="mt-4 px-6 py-3 bg-green-500 hover:bg-green-600 text-white font-bold rounded-full shadow-lg transition-transform transform active:scale-95">‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á</button>
        </div>
        <div id="dialogue-box" class="dialogue-box"></div>
    </div>

    <!-- On-screen touch controls for mobile -->
    <div id="controls" class="absolute bottom-4 left-0 w-full flex justify-between px-4 z-20">
        <button id="left-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-4 px-6 rounded-full shadow-lg transition-transform transform active:scale-95 flex items-center justify-center w-16 h-16 sm:w-20 sm:h-20">
            <!-- Left arrow icon -->
            <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 sm:h-10 sm:w-10" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd" />
            </svg>
        </button>
        <div class="flex flex-col space-y-2">
            <div class="flex space-x-2">
                <button id="jump-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-4 px-6 rounded-full shadow-lg transition-transform transform active:scale-95 flex items-center justify-center w-16 h-16 sm:w-20 sm:h-20">
                    <!-- Up arrow icon -->
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 sm:h-10 sm:w-10" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M14.707 12.707a1 1 0 01-1.414 0L10 9.414l-3.293 3.293a1 1 0 01-1.414-1.414l4-4a1 1 0 011.414 0l4 4a1 1 0 010 1.414z" clip-rule="evenodd" />
                    </svg>
                </button>
                <button id="shoot-button" class="bg-red-500 hover:bg-red-600 text-white font-bold py-4 px-6 rounded-full shadow-lg transition-transform transform active:scale-95 flex items-center justify-center w-16 h-16 sm:w-20 sm:h-20">
                    <!-- Shooting icon -->
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 sm:h-10 sm:w-10" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3" />
                    </svg>
                </button>
            </div>
            <button id="gemini-dialogue-button" class="hidden bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-full shadow-lg transition-transform transform active:scale-95 text-xs sm:text-sm">
                ‚ú® ‡∏ó‡πâ‡∏≤‡∏ó‡∏≤‡∏¢‡∏ö‡∏≠‡∏™
            </button>
        </div>
        <button id="right-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-4 px-6 rounded-full shadow-lg transition-transform transform active:scale-95 flex items-center justify-center w-16 h-16 sm:w-20 sm:h-20">
            <!-- Right arrow icon -->
            <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 sm:h-10 sm:w-10" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd" />
            </svg>
        </button>
    </div>

    <!-- Phaser Library -->
    <script src="//cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.js"></script>

    <!-- Game logic script -->
    <script>
        // Global variables for the game
        let player;
        let cursors;
        let playerHP = 3;
        let hearts = [];
        let scene;
        let enemies;
        let bullets; // Group for player's bullets
        let bossBullets; // Group for boss's bullets
        let score = 0;
        let scoreText;
        let lastPlayerFired = 0; // To control player's bullet firing rate

        // Boss-related variables
        let boss;
        let bossHP = 50;
        let maxBossHP = 50;
        let bossHealthBar;
        let bossInfoContainer;
        let geminiDialogueButton;
        let dialogueBox;
        let isBossActive = false;
        let dialogueTimeout = null;
        let lastBossFired = 0; // To control boss's bullet firing rate
        let bossSpawned = false;

        function startGame() {
            // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤‡πÄ‡∏Å‡∏°‡πÅ‡∏ö‡∏ö Dynamic ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡∏ó‡∏µ‡πà‡πÅ‡∏ï‡∏Å‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô
            const config = {
                type: Phaser.AUTO,
                scale: {
                    mode: Phaser.Scale.FIT,
                    parent: 'game-container',
                    autoCenter: Phaser.Scale.CENTER_BOTH,
                    width: window.innerWidth,
                    height: window.innerHeight,
                },
                backgroundColor: '#333',
                // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Arcade Physics ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡∏°
                physics: {
                    default: 'arcade',
                    arcade: {
                        gravity: { y: 300 },
                        debug: false
                    }
                },
                // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î scenes ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡∏°
                scene: {
                    preload: preload,
                    create: create,
                    update: update
                }
            };
            const game = new Phaser.Game(config);
        }
        
        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô preload ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÇ‡∏´‡∏•‡∏î asset ‡∏Ç‡∏≠‡∏á‡πÄ‡∏Å‡∏°
        function preload() {
            // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û placeholder ‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏û‡∏™‡πÑ‡∏ï‡∏•‡πå‡∏Å‡∏≤‡∏£‡πå‡∏ï‡∏π‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô, ‡∏®‡∏±‡∏ï‡∏£‡∏π, ‡∏Å‡∏£‡∏∞‡∏™‡∏∏‡∏ô ‡πÅ‡∏•‡∏∞‡∏´‡∏±‡∏ß‡πÉ‡∏à
            this.load.image('player', 'https://placehold.co/100x100/A0E7E5/fff?text=üòä');
            this.load.image('heart', 'https://placehold.co/50x50/F85050/fff?text=‚ù§Ô∏è');
            this.load.image('ground', 'https://placehold.co/100x30/28a745/fff?text=Ground');
            this.load.image('enemy', 'https://placehold.co/100x100/FFD966/000?text=üëπ');
            this.load.image('player_bullet', 'https://placehold.co/20x20/FFD966/000?text=‚ú®');
            this.load.image('boss', 'https://placehold.co/200x200/B22222/fff?text=BOSS');
            this.load.image('boss_bullet', 'https://placehold.co/20x20/3A0CA3/fff?text=üíÄ');
        }

        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô create ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Ç‡∏≠‡∏á‡πÄ‡∏Å‡∏°
        function create() {
            scene = this;
            
            // Get references to HTML elements
            bossInfoContainer = document.getElementById('boss-info');
            bossHealthBar = document.getElementById('boss-health-bar');
            geminiDialogueButton = document.getElementById('gemini-dialogue-button');
            dialogueBox = document.getElementById('dialogue-box');

            // Create a static ground platform at the bottom of the screen
            const groundHeight = 30;
            const ground = this.physics.add.staticGroup();
            ground.create(this.scale.width / 2, this.scale.height - groundHeight / 2, 'ground')
                  .setScale(this.scale.width / 50, 1)
                  .refreshBody();

            // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡πÑ‡∏õ‡∏£‡∏ó‡πå‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô
            player = this.physics.add.sprite(this.scale.width / 4, this.scale.height - 100, 'player').setScale(0.5);
            player.setCollideWorldBounds(true);
            this.physics.add.collider(player, ground);
            
            // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏®‡∏±‡∏ï‡∏£‡∏π
            enemies = this.physics.add.group();
            // ‡∏™‡∏£‡πâ‡∏≤‡∏á event ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏∏‡πà‡∏°‡∏®‡∏±‡∏ï‡∏£‡∏π‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏∏‡∏Å‡πÜ 5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
            this.time.addEvent({
                delay: 5000,
                callback: createRandomEnemy,
                callbackScope: this,
                loop: true
            });

            // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏£‡∏∞‡∏™‡∏∏‡∏ô‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô
            bullets = this.physics.add.group();
            // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏£‡∏∞‡∏™‡∏∏‡∏ô‡∏Ç‡∏≠‡∏á‡∏ö‡∏≠‡∏™
            bossBullets = this.physics.add.group();

            this.physics.add.collider(enemies, ground);
            this.physics.add.collider(boss, ground);
            this.physics.add.overlap(player, enemies, handlePlayerEnemyCollision, null, this);
            this.physics.add.overlap(player, boss, handlePlayerBossCollision, null, this);
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ä‡∏ô‡∏Å‡∏±‡∏ô‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏£‡∏∞‡∏™‡∏∏‡∏ô‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏Å‡∏±‡∏ö‡∏®‡∏±‡∏ï‡∏£‡∏π
            this.physics.add.overlap(bullets, enemies, handleBulletEnemyCollision, null, this);
            this.physics.add.overlap(bullets, boss, handleBulletBossCollision, null, this);
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ä‡∏ô‡∏Å‡∏±‡∏ô‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏£‡∏∞‡∏™‡∏∏‡∏ô‡∏Ç‡∏≠‡∏á‡∏ö‡∏≠‡∏™‡∏Å‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô
            this.physics.add.overlap(player, bossBullets, handlePlayerBossBulletCollision, null, this);
            this.physics.add.collider(bossBullets, ground, (bullet) => {
                bullet.disableBody(true, true);
            });

            // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏±‡∏ß‡∏ü‡∏±‡∏á‡∏Å‡∏≤‡∏£‡∏õ‡πâ‡∏≠‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡πÅ‡∏õ‡πâ‡∏ô‡∏û‡∏¥‡∏°‡∏û‡πå
            cursors = this.input.keyboard.createCursorKeys();
            
            // Initial score text
            scoreText = this.add.text(16, 16, '‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô: 0', { fontSize: '20px', fill: '#fff' }).setScrollFactor(0);

            // Initialize and display player hearts
            updateHearts();

            // Mobile controls
            const leftButton = document.getElementById('left-button');
            const rightButton = document.getElementById('right-button');
            const jumpButton = document.getElementById('jump-button');
            const shootButton = document.getElementById('shoot-button');

            leftButton.addEventListener('touchstart', () => player.isMovingLeft = true);
            leftButton.addEventListener('touchend', () => player.isMovingLeft = false);
            rightButton.addEventListener('touchstart', () => player.isMovingRight = true);
            rightButton.addEventListener('touchend', () => player.isMovingRight = false);
            jumpButton.addEventListener('touchstart', () => {
                if (player.body.touching.down) {
                    player.setVelocityY(-330);
                }
            });
            // Shoot button listener with cooldown
            shootButton.addEventListener('touchstart', () => {
                // Check for cooldown
                if (scene.time.now > lastPlayerFired + 500) {
                    shootBullet();
                    lastPlayerFired = scene.time.now;
                }
            });

            // Gemini API button listener
            geminiDialogueButton.addEventListener('click', () => {
                if (isBossActive) {
                    generateBossDialogue();
                }
            });
        }

        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ö‡∏≠‡∏™
        function createBoss(x, y) {
            isBossActive = true;
            boss = scene.physics.add.sprite(x, y, 'boss').setScale(0.8);
            boss.setCollideWorldBounds(true);
            boss.setBounce(0.2); // Boss will bounce slightly
            boss.minX = scene.scale.width * 0.6;
            boss.maxX = scene.scale.width * 0.9;
            boss.direction = -1;
            boss.speed = 80;
            boss.setVelocityX(boss.speed * boss.direction);
            
            // Show the boss health bar and Gemini button
            bossInfoContainer.style.display = 'flex';
            geminiDialogueButton.style.display = 'block';
        }

        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏®‡∏±‡∏ï‡∏£‡∏π‡∏ó‡∏µ‡πà‡∏•‡∏≤‡∏î‡∏ï‡∏£‡∏∞‡πÄ‡∏ß‡∏ô‡πÅ‡∏ö‡∏ö‡∏™‡∏∏‡πà‡∏°
        function createRandomEnemy() {
            if (!isBossActive) {
                const x = Phaser.Math.Between(scene.scale.width * 0.2, scene.scale.width * 0.8);
                const enemy = enemies.create(x, scene.scale.height - 100, 'enemy').setScale(0.5);
                enemy.setCollideWorldBounds(true);
                enemy.minX = x - 100;
                enemy.maxX = x + 100;
                enemy.direction = Phaser.Math.Between(0, 1) ? 1 : -1;
                enemy.speed = Phaser.Math.Between(50, 120);
                enemy.setVelocityX(enemy.speed * enemy.direction);
            }
        }

        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô update ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏±‡∏ô‡∏ó‡∏∏‡∏Å‡πÄ‡∏ü‡∏£‡∏°
        function update() {
            // Player movement control from keyboard
            if (cursors.left.isDown) {
                player.setVelocityX(-160);
            } else if (cursors.right.isDown) {
                player.setVelocityX(160);
            } else if (!player.isMovingLeft && !player.isMovingRight) {
                player.setVelocityX(0);
            }
            
            // Player movement control from touch
            if (player.isMovingLeft) {
                player.setVelocityX(-160);
            } else if (player.isMovingRight) {
                player.setVelocityX(160);
            }

            // Player jump control from keyboard
            if (cursors.up.isDown && player.body.touching.down) {
                player.setVelocityY(-330);
            }

            // Enemy patrolling logic
            enemies.children.iterate(enemy => {
                if (enemy.x <= enemy.minX && enemy.direction === -1) {
                    enemy.direction = 1;
                    enemy.speed = Phaser.Math.Between(50, 120);
                    enemy.setVelocityX(enemy.speed);
                }
                if (enemy.x >= enemy.maxX && enemy.direction === 1) {
                    enemy.direction = -1;
                    enemy.speed = Phaser.Math.Between(50, 120);
                    enemy.setVelocityX(-enemy.speed);
                }
            });

            // Check if the boss should be spawned
            if (score >= 100 && !bossSpawned) {
                createBoss(scene.scale.width * 0.75, scene.scale.height - 150);
                bossSpawned = true;
            }

            // Boss patrolling and shooting logic
            if (isBossActive && boss) {
                if (boss.x <= boss.minX && boss.direction === -1) {
                    boss.direction = 1;
                    boss.setVelocityX(boss.speed);
                }
                if (boss.x >= boss.maxX && boss.direction === 1) {
                    boss.direction = -1;
                    boss.setVelocityX(-boss.speed);
                }

                // Boss shoots at the player every 2 seconds
                if (scene.time.now > lastBossFired + 2000) {
                    bossShoot();
                    lastBossFired = scene.time.now;
                }
            }
        }
        
        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏¢‡∏¥‡∏á‡∏Å‡∏£‡∏∞‡∏™‡∏∏‡∏ô‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô
        function shootBullet() {
            const bullet = bullets.get(player.x, player.y, 'player_bullet');
            if (bullet) {
                bullet.setActive(true);
                bullet.setVisible(true);
                bullet.body.allowGravity = false;
                bullet.setVelocityX(400); // Speed of the bullet
            }
        }

        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ö‡∏≠‡∏™‡∏¢‡∏¥‡∏á‡∏Å‡∏£‡∏∞‡∏™‡∏∏‡∏ô
        function bossShoot() {
            const bullet = bossBullets.get(boss.x, boss.y, 'boss_bullet');
            if (bullet) {
                bullet.setActive(true);
                bullet.setVisible(true);
                bullet.body.allowGravity = false;

                // Calculate velocity to shoot towards the player
                scene.physics.moveToObject(bullet, player, 200);
            }
        }

        // ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡∏ä‡∏ô‡∏Å‡∏±‡∏ô‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÅ‡∏•‡∏∞‡∏®‡∏±‡∏ï‡∏£‡∏π
        function handlePlayerEnemyCollision(player, enemy) {
            if (!player.invincible) {
                loseHP();
                player.invincible = true;
                scene.tweens.add({
                    targets: player,
                    alpha: { from: 1, to: 0.2 },
                    yoyo: true,
                    repeat: 5,
                    duration: 100,
                    onComplete: () => {
                        player.alpha = 1;
                        player.invincible = false;
                    }
                });
            }
        }

        // ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡∏ä‡∏ô‡∏Å‡∏±‡∏ô‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÅ‡∏•‡∏∞‡∏ö‡∏≠‡∏™
        function handlePlayerBossCollision(player, boss) {
            if (!player.invincible) {
                loseHP();
                player.invincible = true;
                scene.tweens.add({
                    targets: player,
                    alpha: { from: 1, to: 0.2 },
                    yoyo: true,
                    repeat: 5,
                    duration: 100,
                    onComplete: () => {
                        player.alpha = 1;
                        player.invincible = false;
                    }
                });
            }
        }

        // ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡∏ä‡∏ô‡∏Å‡∏±‡∏ô‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏£‡∏∞‡∏™‡∏∏‡∏ô‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÅ‡∏•‡∏∞‡∏®‡∏±‡∏ï‡∏£‡∏π
        function handleBulletEnemyCollision(bullet, enemy) {
            bullet.disableBody(true, true);
            enemy.disableBody(true, true);
            score += 10;
            scoreText.setText('‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô: ' + score);
        }

        // ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡∏ä‡∏ô‡∏Å‡∏±‡∏ô‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏£‡∏∞‡∏™‡∏∏‡∏ô‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÅ‡∏•‡∏∞‡∏ö‡∏≠‡∏™
        function handleBulletBossCollision(bullet, boss) {
            bullet.disableBody(true, true);
            bossHP -= 1;
            bossHealthBar.style.width = (bossHP / maxBossHP) * 100 + '%';

            if (bossHP <= 0) {
                boss.disableBody(true, true);
                winGame();
            }
        }

        // ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡∏ä‡∏ô‡∏Å‡∏±‡∏ô‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏£‡∏∞‡∏™‡∏∏‡∏ô‡∏Ç‡∏≠‡∏á‡∏ö‡∏≠‡∏™‡πÅ‡∏•‡∏∞‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô
        function handlePlayerBossBulletCollision(player, bullet) {
            bullet.disableBody(true, true);
            if (!player.invincible) {
                loseHP();
                player.invincible = true;
                scene.tweens.add({
                    targets: player,
                    alpha: { from: 1, to: 0.2 },
                    yoyo: true,
                    repeat: 5,
                    duration: 100,
                    onComplete: () => {
                        player.alpha = 1;
                        player.invincible = false;
                    }
                });
            }
        }

        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏´‡∏±‡∏ß‡πÉ‡∏à
        function updateHearts() {
            hearts.forEach(h => h.destroy());
            hearts = [];
            for (let i = 0; i < playerHP; i++) {
                const heart = scene.add.image(30 + i * 40, 50, 'heart')
                    .setScrollFactor(0)
                    .setScale(0.5)
                    .setOrigin(0, 0);
                hearts.push(heart);
            }
        }

        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏î HP ‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô
        function loseHP() {
            if (playerHP > 0) {
                playerHP--;
                updateHearts();
                if (playerHP <= 0) {
                    loseGame();
                }
            }
        }

        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ Game Over
        function loseGame() {
            endGame('GAME OVER');
        }

        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ Game Win
        function winGame() {
            endGame('YOU WIN!');
        }

        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏ö‡πÄ‡∏Å‡∏°
        function endGame(title) {
            document.getElementById('end-game-text').style.display = 'flex';
            document.getElementById('end-game-title').textContent = title;
            document.getElementById('final-score').textContent = '‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢: ' + score;
            player.setTint(0xff0000);
            player.setVelocity(0, 0);
            player.anims.stop();
            player.body.enable = false;
            if (boss) {
                boss.setVelocity(0,0);
            }
            isBossActive = false;
            geminiDialogueButton.style.display = 'none';

            // Show the "Play Again" button
            document.getElementById('play-again-button').style.display = 'block';
            // Add event listener to reload the page
            document.getElementById('play-again-button').addEventListener('click', () => {
                window.location.reload();
            });
        }
        
        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Gemini API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ö‡∏ó‡∏û‡∏π‡∏î‡∏Ç‡∏≠‡∏á‡∏ö‡∏≠‡∏™
        async function generateBossDialogue() {
            geminiDialogueButton.disabled = true;
            geminiDialogueButton.textContent = '...‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ñ‡∏¥‡∏î‡∏≠‡∏¢‡∏π‡πà';
            
            // Clear any previous dialogue timeout
            if (dialogueTimeout) {
                clearTimeout(dialogueTimeout);
            }

            try {
                const prompt = "‡∏Ñ‡∏∏‡∏ì‡∏Ñ‡∏∑‡∏≠‡∏ö‡∏≠‡∏™‡πÉ‡∏ô‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡πÄ‡∏Å‡∏°‡∏™‡πÑ‡∏ï‡∏•‡πå‡∏¢‡πâ‡∏≠‡∏ô‡∏¢‡∏∏‡∏Ñ ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏î‡πâ‡∏ß‡∏¢‡∏Ñ‡∏≥‡∏û‡∏π‡∏î‡πÄ‡∏¢‡∏≤‡∏∞‡πÄ‡∏¢‡πâ‡∏¢‡∏™‡∏±‡πâ‡∏ô‡πÜ ‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ó‡πâ‡∏≤‡∏ó‡∏≤‡∏¢‡πÄ‡∏Ç‡∏≤ ‡∏¢‡∏Å‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏ä‡πà‡∏ô '‡πÄ‡∏à‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ó‡∏≤‡∏á‡πÄ‡∏≠‡∏≤‡∏ä‡∏ô‡∏∞‡∏Ç‡πâ‡∏≤‡πÑ‡∏î‡πâ‡∏´‡∏£‡∏≠‡∏Å!' ‡∏´‡∏£‡∏∑‡∏≠ '‡∏û‡∏•‡∏±‡∏á‡∏Ç‡∏≠‡∏á‡πÄ‡∏à‡πâ‡∏≤‡∏°‡∏±‡∏ô‡∏Å‡∏£‡∏∞‡∏à‡∏≠‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ!'. ‡∏ï‡∏≠‡∏ö‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô.";
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiKey = ""
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    dialogueBox.textContent = text;
                    dialogueBox.style.display = 'block';

                    // Hide the dialogue box after a few seconds
                    dialogueTimeout = setTimeout(() => {
                        dialogueBox.style.display = 'none';
                    }, 5000);
                } else {
                    dialogueBox.textContent = "‡∏ö‡∏≠‡∏™: ‡∏Ç‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏£‡∏à‡∏∞‡∏û‡∏π‡∏î‡∏Å‡∏±‡∏ö‡πÄ‡∏à‡πâ‡∏≤‡πÉ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ!";
                    dialogueBox.style.display = 'block';
                }
            } catch (error) {
                console.error("Error calling Gemini API:", error);
                dialogueBox.textContent = "‡∏ö‡∏≠‡∏™: ‡∏Ç‡πâ‡∏≤‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏¢‡∏∏‡πà‡∏á‡∏≠‡∏¢‡∏π‡πà! ‡πÑ‡∏õ‡πÉ‡∏´‡πâ‡∏û‡πâ‡∏ô!";
                dialogueBox.style.display = 'block';
            } finally {
                geminiDialogueButton.disabled = false;
                geminiDialogueButton.textContent = '‚ú® ‡∏ó‡πâ‡∏≤‡∏ó‡∏≤‡∏¢‡∏ö‡∏≠‡∏™';
            }
        }


        // Poll for the Phaser object before starting the game
        const checkPhaser = setInterval(() => {
            if (window.Phaser) {
                clearInterval(checkPhaser);
                startGame();
            }
        }, 10);
    </script>
</body>
</html>
